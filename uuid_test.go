package uuid

import (
	"bytes"
	"crypto/rand"
	"net"
	"reflect"
	"testing"
	"time"
)

const (
	testVecTimeCustom int64 = 1621171244987654321 // 2021-05-16T13:20:44.987654321Z
	testVecTimeRFC    int64 = 1645557742000000000 // 2022-02-22T07:22:22.00Z
)

func testTime(tm int64) {
	CurrentTime = func() time.Time { return time.Unix(0, tm) }
}

func trueTime() {
	CurrentTime = time.Now
}

var random = rand.Reader // store rand.Reader since it is replaced by static data by some tests

func testRand(b ...byte) {
	rand.Reader = bytes.NewBuffer(b)
}

func trueRand() {
	rand.Reader = random
}

func TestMustString(t *testing.T) {
	trueRand()
	id := MustString(NewV4())
	if len(id) != 36 {
		t.Errorf("Generated UUID length is invalid. Should be 36 but is: %d", len(id))
	}
	if id[8] != '-' || id[13] != '-' || id[18] != '-' || id[23] != '-' {
		t.Errorf("Dash placement invalid. Should be 8, 13, 18, 23 but is %s", id)
	}
}

func TestUUID_IsNil(t *testing.T) {
	tests := []struct {
		name string
		UUID *UUID
		want bool
	}{
		{"NotNil", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x46, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, false},
		{"Nil", &UUID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.UUID.IsNil(); got != tt.want {
				t.Errorf("UUID.IsNil() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUUID_IsMax(t *testing.T) {
	tests := []struct {
		name string
		UUID *UUID
		want bool
	}{
		{"NotMax", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x46, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, false},
		{"Max", &UUID{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.UUID.IsMax(); got != tt.want {
				t.Errorf("UUID.IsMax() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUUID_Version(t *testing.T) {
	tests := []struct {
		name string
		UUID *UUID
		want int
	}{
		{"V0", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x06, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 0},
		{"V1", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x16, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 1},
		{"V2", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x26, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 2},
		{"V3", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x36, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 3},
		{"V4", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x46, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 4},
		{"V5", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x56, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 5},
		{"V6", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x66, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 6},
		{"V7", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x76, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 7},
		{"V8", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x86, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 8},
		{"V9", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x96, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 9},
		{"V10", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0xA6, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 10},
		{"V11", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0xB6, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 11},
		{"V12", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0xC6, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 12},
		{"V13", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0xD6, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 13},
		{"V14", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0xE6, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 14},
		{"V15", &UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0xF6, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, 15},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.UUID.Version(); got != tt.want {
				t.Errorf("UUID.Version() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUUID_Timestamp(t *testing.T) {
	tests := []struct {
		name string
		uuid UUID
		want time.Time
	}{
		{"UUIDv7", UUID{0x01, 0x79, 0x75, 0x56, 0x0F, 0xBB, 0x70, 0x00, 0x81, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}, time.Unix(1621171244, 987*1000000)},
		{"UUIDv4", UUID{0x68, 0x6e, 0x77, 0x78, 0xf9, 0xf0, 0x46, 0x22, 0xa1, 0x3e, 0xc2, 0x44, 0x1c, 0xe4, 0xae, 0x41}, time.Unix(0, 0)},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.uuid.Timestamp(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UUID.Timestamp() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_intervalsSinceEpoch(t *testing.T) {
	tests := []struct {
		name     string
		fakeTime int64
		want     int64
	}{
		{"TestTime", testVecTimeCustom, 138404640449876543},
		{"TestTime+1d", testVecTimeCustom + 86400000000000, 138404640449876543 + 864000000000},
		{"TestTime-3y", testVecTimeCustom - 94672800000000000, 138404640449876543 - 946728000000000},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testTime(tt.fakeTime)
			diff1 := time.Date(1800, 1, 1, 0, 0, 0, 0, time.UTC).Sub(time.Date(1582, 10, 15, 0, 0, 0, 0, time.UTC)).Nanoseconds() / 100
			diff2 := CurrentTime().Sub(time.Date(1800, 1, 1, 0, 0, 0, 0, time.UTC)).Nanoseconds() / 100
			diff := diff1 + diff2
			if got := intervalsSinceEpoch(); got != tt.want {
				t.Errorf("intervalsSinceEpoch() = %v, want %v, calculated %v", got, tt.want, diff)
			}
		})
	}
}

func Test_getHWAddr(t *testing.T) {
	tests := []struct {
		name        string
		useHWMAC    bool
		fakeRandom  []byte
		resetRandom bool
		want        net.HardwareAddr
		wantErr     bool
	}{
		{"DeviceMAC", true, nil, false, nil, false},
		{"RandomMAC", false, []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}, false, []byte{0x03, 0x23, 0x45, 0x67, 0x89, 0xAB}, false},
		{"SameRandomMAC", false, nil, false, []byte{0x03, 0x23, 0x45, 0x67, 0x89, 0xAB}, false},
		{"DifferentRandomMAC", false, []byte{0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10}, true, []byte{0xFF, 0xDC, 0xBA, 0x98, 0x76, 0x54}, false},
		{"NoRandom", false, nil, true, nil, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			UseHardwareMAC = tt.useHWMAC
			testRand(tt.fakeRandom...)
			if tt.resetRandom {
				RandomMAC = nil
			}
			got, err := getHWAddr()
			if (err != nil) != tt.wantErr {
				t.Errorf("getHWAddr() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.want == nil && !tt.wantErr && (got == nil || got[0]&0x03 != 0x00) {
				t.Errorf("getHWAddr() = %v, which is not global unicast", got)
			}
			if tt.want != nil && !reflect.DeepEqual(got, tt.want) {
				t.Errorf("getHWAddr() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_getHWAddrRandom(t *testing.T) {
	trueRand()
	UseHardwareMAC = false
	for i := 0; i < 1000; i++ {
		RandomMAC = nil
		addr, err := getHWAddr()
		if err != nil {
			t.Errorf("getHWAddr() error = %v", err)
		}
		if addr == nil {
			t.Errorf("getHWAddr() returned nil value without error")
		}
		if len(addr) != 6 {
			t.Errorf("getHWAddr() returned invalid length %d", len(addr))
		}
		if addr[0]&0x03 != 0x03 {
			t.Errorf("getHWAddr() = %v, which is not local multicast", addr)
		}
	}
}
