package uuid

import (
	"reflect"
	"testing"
)

func TestNewV1(t *testing.T) {
	tests := []struct {
		name        string
		fakeTime    int64
		fakeRandom  []byte
		resetMAC    bool
		hardwareMAC bool
		wantUUID    UUID
		wantErr     bool
	}{
		{"Default", testVecTimeRFC, []byte{0x33, 0xC8, 0x9E, 0x6B, 0xDE, 0xCE, 0xD8, 0x46}, true, false, UUID{0xC2, 0x32, 0xAB, 0x00, 0x94, 0x14, 0x11, 0xEC, 0xB3, 0xC8, 0x9F, 0x6B, 0xDE, 0xCE, 0xD8, 0x46}, false},
		{"Sequence", testVecTimeRFC, []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}, false, false, UUID{0xC2, 0x32, 0xAB, 0x00, 0x94, 0x14, 0x11, 0xEC, 0xB3, 0xC9, 0x9F, 0x6B, 0xDE, 0xCE, 0xD8, 0x46}, false},
		{"SequenceNoRandom", testVecTimeRFC, nil, false, false, UUID{0xC2, 0x32, 0xAB, 0x00, 0x94, 0x14, 0x11, 0xEC, 0xB3, 0xCA, 0x9F, 0x6B, 0xDE, 0xCE, 0xD8, 0x46}, false},
		{"DifferentTime", testVecTimeCustom, []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}, false, false, UUID{0x85, 0x47, 0xD2, 0x3F, 0xB6, 0x49, 0x11, 0xEB, 0x81, 0x23, 0x9F, 0x6B, 0xDE, 0xCE, 0xD8, 0x46}, false},
		{"DifferentTimeNoRandom", testVecTimeRFC, nil, false, false, UUID{}, true},
		{"NewMAC", testVecTimeRFC, []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}, true, false, UUID{0xC2, 0x32, 0xAB, 0x00, 0x94, 0x14, 0x11, 0xEC, 0x81, 0x23, 0x47, 0x67, 0x89, 0xAB, 0xCD, 0xEF}, false},
		{"NewMACNoRandom", testVecTimeRFC, nil, true, false, UUID{}, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testTime(tt.fakeTime)
			testRand(tt.fakeRandom...)
			if tt.resetMAC {
				RandomMAC = nil
			}
			UseHardwareMAC = tt.hardwareMAC
			gotUUID, err := NewV1()
			if (err != nil) != tt.wantErr {
				t.Errorf("NewV1() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(gotUUID, tt.wantUUID) {
				t.Errorf("NewV1() = %v, want %v", gotUUID, tt.wantUUID)
			}
		})
	}
}
